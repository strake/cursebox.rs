use core::slice;

pub static utf8_length: [u8; 256] = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,
];

static utf8_mask: [u8; 7] = [0, 0x7F, 0x1F, 0x0F, 0x07, 0x03, 0x01];

pub fn decode(bs: &[u8]) -> Option<(u32, usize)> {
    let l = utf8_length[bs[0] as usize] as usize;
    if l > bs.len() { return None }
    let bs = unsafe { slice::from_raw_parts(bs.as_ptr(), !0) };
    let mut x = (bs[0] & unsafe { *utf8_mask.get_unchecked(l) }) as u32;
    for i in 1..l {
        x <<= 6;
        x |= bs[i] as u32 & 0x3F;
    }
    Some((x, l))
}
